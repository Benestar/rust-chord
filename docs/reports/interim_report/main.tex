\documentclass[a4paper, 11pt]{article}
\usepackage{comment} % enables the use of multi-line comments (\ifx \fi) 
\usepackage{lipsum} %This package just generates Lorem Ipsum filler text. 
\usepackage{fullpage} % changes the margin
\usepackage{todonotes}
\usepackage{hyperref}

%\documentclass[border=10pt,png]{standalone}
\usepackage{bytefield}

\begin{document}
%Header-Make sure you update this information!!!!
\noindent
\large\textbf{VoidPhone Project} \hfill \textbf{Interim Report}\\
\normalsize P2PSEC (IN2194)  \hfill Team 45 - Rhodium\\
Prof. Dr.-Ing Georg Carle \hfill Benedikt Seidl, Stefan Su\\
Sree Harsha Totakura, Dr. Heiko Niedermayer \hfill Due Date: 06/08/18

\section*{Process Architecture}

Our DHT implementation will be based on TCP connections for both the api interface and the peer-to-peer communication. Therefore, we listen on two ports given in the config for the two interfaces and wait for incoming connections in two event loops.

Each incoming request should be handled as fast as possible. Therefore we want to use parallelization to balance the load on several cores. This can be achieved by several means, for example starting several processes or using multi-threading.
Using multiple processes makes sense when there is little communication needed between each process since inter-process communication is quite expensive.

However, since we need to work on shared memory between requests and also because we expect each request to only take very short to process, our preferred solution for parallelization is multi-threading. For this purpose, we use the thread pool pattern which creates a given number of worker threads and handles jobs from a job queue. Whenever a request reaches our server, it creates a new task to handle this request and adds it to the queue. This allows us to work concurrently while not having the overhead of spawning too many threads.

% using thread pool to parallelize handling of incoming connecitons
% no separate processes to avoid inter-process communication overhead

% Same modules and structs for api and p2p protocols


\section*{Inter-module protocol}

% We use Chord (key based routing protocol) based on consistent hashing
% blablabla (Paper zitieren)

\cite{ChordPaper}

\subsection*{Message formats}

Some sample message formats.
\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{FIND PEER}} \\
			\bitbox{16}{TTL} & \bitbox{8}{replication} & \bitbox{8}{reserved}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
		\wordbox[lrt]{1}{value} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT PUT message}
	\label{DHTPUT}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{PEER GET}}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT GET message}
	\label{DHTGET}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{DHT SUCCESS}}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
		\wordbox[lrt]{1}{value} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT SUCCESS message}
	\label{DHTSUCCESS}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{DHT FAILURE}}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT FAILURE message}
	\label{DHTFAILURE}
\end{figure}

\subsection*{Authentication}

\todo{TODO}

% Handshakes for every communication too expensive
% When new node joins, it has to check whether the bootstrap node
% runs the correct software.

There are several cases that may occur:

\begin{enumerate}
	\item No module is running on the port that we appointed.
	\item Another service is running on our DHT port that possesses uncompliant message formats.
	\item Another service is running on our DHT port that just happens to use the same message types that we defined.
\end{enumerate}

For our implementation we only need to actively mitigate case 3., as there are no consequences that would influence the behavior of our module in case 1. and 2. respectively. In case 1., we would not receive any response message and in case 2. we wouldn't be able to process messages coming back from the foreign service anyway. Case 3. however would result in unpredictable behavior, if the message types of the foreign service were to align ours and we would start processing unknown, possibly malicious payloads. For this, we add a magic number field to our message formats \todo{Magic numbers are no secret.., proof-of-work?}

\subsection*{Failure handling}

\todo{TODO}


\bibliographystyle{IEEEtran}
\bibliography{../bibliography}

\pagebreak

\section*{A. Message Types}

\todo{TODO}

\end{document}
