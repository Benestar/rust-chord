\documentclass[a4paper, 11pt]{article}
\usepackage{comment} % enables the use of multi-line comments (\ifx \fi) 
\usepackage{lipsum} %This package just generates Lorem Ipsum filler text. 
\usepackage{fullpage} % changes the margin
\usepackage{todonotes}
\usepackage{hyperref}

%\documentclass[border=10pt,png]{standalone}
\usepackage{bytefield}

\begin{document}
%Header-Make sure you update this information!!!!
\noindent
\large\textbf{VoidPhone Project} \hfill \textbf{Interim Report}\\
\normalsize P2PSEC (IN2194)  \hfill Team 45 - Rhodium\\
Prof. Dr.-Ing Georg Carle \hfill Benedikt Seidl, Stefan Su\\
Sree Harsha Totakura, Dr. Heiko Niedermayer \hfill Due Date: 06/08/18

\section*{Introduction}

In this document, we describe the planned design and implementation of our distributed hash table (DHT) module for the VoidPhone Project. A DHT allows to store key-value pairs in a distributed network of peers. No peer has to store the whole hash table but every node in the network provides some storage and computing capacity to realize a functional system \footnote{We use ``peer'' and ``node'' as synonyms throughout this document. In the context of networks and graphs, we usually talk about nodes while on the implementation level they are called peers.}.

We distinguish between the api interface which is used to communicate with other modules on the same peer and the peer-to-peer or inter-module interface which allows the DHT modules on different peers to interact. The DHT provides two operations via its api interface, namely PUT and GET, which are used to store a value under a given key and later obtain the value for this key. The peer-to-peer protocol is more complicated and will be discussed in this document after introducing our architecture design.

\section*{Architecture Design}

\subsection*{Application Architecture}

To realize the distributed hash table (DHT) we will implement the \textit{Chord} protocol. The central aspect of Chord is to provided key-based routing. This means to map a given key to a node in the network.

\subsection*{Process Architecture}

Our DHT implementation will be based on TCP for both the api interface and the peer-to-peer communication. Therefore, we listen on two ports given in the config for the two interfaces and wait for incoming connections in two event loops.

Each incoming request should be handled as fast as possible. Therefore we want to use parallelization to balance the load on several cores. This can be achieved by several means, for example starting several processes or using multi-threading.
Using multiple processes makes sense when there is little communication needed between each process since inter-process communication is quite expensive.

However, since we need to work on shared memory between requests and also because we expect each request to only take very short to process, our preferred solution for parallelization is multi-threading. For this purpose, we use the thread pool pattern which creates a given number of worker threads and handles jobs from a job queue. Whenever a request reaches our server, it creates a new task to handle this request and adds it to the queue. This allows us to work concurrently while not having the overhead of spawning too many threads.

% using thread pool to parallelize handling of incoming connecitons
% no separate processes to avoid inter-process communication overhead

% Same modules and structs for api and p2p protocols


\section*{Inter-module protocol}

% We use Chord (key based routing protocol) based on consistent hashing
% blablabla (Paper zitieren)

\cite{ChordPaper}

\subsection*{Message formats}

Some sample message formats.
\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{FIND PEER}} \\
			\bitbox{16}{TTL} & \bitbox{8}{replication} & \bitbox{8}{reserved}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
		\wordbox[lrt]{1}{value} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT PUT message}
	\label{DHTPUT}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{PEER GET}}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT GET message}
	\label{DHTGET}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{DHT SUCCESS}}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
		\wordbox[lrt]{1}{value} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT SUCCESS message}
	\label{DHTSUCCESS}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{bytefield}[bitwidth=0.8em]{32}
		\bitheader{0,7,8,15,16,23,24,31} \\
		\begin{rightwordgroup}{Message \\  Header}
			\bitbox{16}{size} & \bitbox{16}{\texttt{DHT FAILURE}}
		\end{rightwordgroup} \\
		\wordbox[lrt]{1}{key (256 bits)} \\
		\skippedwords \\
		\wordbox[lrb]{1}{} \\
	\end{bytefield}
	\caption{DHT FAILURE message}
	\label{DHTFAILURE}
\end{figure}

\subsection*{Authentication}
When a new peer $p$ joins the network, both the bootstrap peer and $p$ need to verify whether they are running the correct software. There are several cases that may occur:
\todo{TODO}
\begin{enumerate}
	\item No module is running on the port that we appointed.
	\item Another service is running on our DHT port that possesses uncompliant message formats.
	\item Another service is running on our DHT port that just happens to use the same message types that we defined.
\end{enumerate}

For our implementation we only need to actively mitigate case 3., as there are no consequences that would influence the behavior of our module in case 1. and 2. respectively. In case 1., we would not receive any response message and in case 2. we wouldn't be able to process messages coming back from the foreign service anyway. Case 3. however would result in unpredictable behavior, if the message types of the foreign service were to align ours and we would start processing unknown, possibly malicious payloads. Establishing handshakes for every communication request however is very expensive due to the messaging overhead. For this, we add a magic number field to our message formats \todo{Magic numbers are no secret.., proof-of-work?}

\subsection*{Failure handling}
Chord's stabilization protocol protocol handles situations such as peers joining, failing or leaving the system \cite{ChordPaper}. Maintaining correct successor pointers will guarantee the correctness of finding predecessors of a node. This is achieved by keeping a ``successor-list'' of the $r$ nearest successors on the identifier ring. That way, ``stabilize'' will fix finger table entries and references pointing to the failed node. The successor list would also help with the objective of maintaining redundancy while storing key-value pairs by informing the storage layer of the state of the successors and therefore where the values need to be replicated to \cite{ChordPaper}. 
\todo{TODO: mention store and chord layer?}


\bibliographystyle{IEEEtran}
\bibliography{../bibliography}

\pagebreak

\section*{A. Message Types}

\todo{TODO}

\end{document}
